generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["fullTextSearch", "filteredRelationCount"]
  binaryTargets   = ["native", "debian-openssl-1.1.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Account, Session, User and VerificationToken
// Match next-auth model https://next-auth.js.org/adapters/prisma
// Underscored names are because of this.
model Account {
  id                String  @id @default(cuid())
  userId            String  @db.Uuid
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(uuid()) @db.Uuid
  sessionToken String   @unique
  userId       String   @db.Uuid
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

enum UserStatus {
  Active
  Disabled
}

enum UserRole {
  Administrator
  StructureManager
  SocialWorker
  Instructor
  ReceptionAgent
  Referent
}

model User {
  id            String     @id @default(uuid()) @db.Uuid
  firstName     String?
  lastName      String?
  name          String?
  email         String     @unique
  emailVerified DateTime?
  image         String?
  role          UserRole
  status        UserStatus @default(value: Active)

  location    String?
  title       String?
  description String?
  accounts    Account[]
  sessions    Session[]

  created DateTime @default(now())
  updated DateTime @default(now())

  structure            Structure?     @relation(fields: [structureId], references: [id])
  structureId          String?        @db.Uuid
  createdFollowups     Followup[]     @relation(name: "created_followups")
  createdHelpRequests  HelpRequest[]  @relation(name: "created_help_requests")
  createdDocuments     Document[]
  createdFollowupTypes FollowupType[]

  createdBeneficiaries Beneficiary[] @relation(name: "created_beneficiaries")
  referentFor          Beneficiary[] @relation(name: "beneficiary_referents")

  doneMutations MutationLog[] @relation(name: "mutation_by")

  targetForMutations MutationLog[] @relation(name: "mutation_target")
}

enum StructureType {
  Ccas
  Cias
  Commune
  Association
  Ministere
}

model Structure {
  id                    String                 @id @db.Uuid
  type                  StructureType
  name                  String
  zipcode               String
  city                  String
  address               String
  phone                 String
  email                 String
  followupTypes         FollowupType[]
  users                 User[]
  helpRequests          HelpRequest[]
  followups             Followup[]
  proposedFollowupTypes ProposedFollowupType[]

  beneficiaries Beneficiary[]

  created            DateTime      @default(now())
  updated            DateTime      @default(now())
  targetForMutations MutationLog[]
}

enum DocumentType {
  Cerfa
  HistoriqueCourrier
  Justificatifs
  Rapports
}

model Document {
  key          String       @id
  mimeType     String
  name         String
  type         DocumentType
  // Size in bytes
  size         Int
  tags         String[]
  confidential Boolean

  beneficiary   Beneficiary @relation(fields: [beneficiaryId], references: [id])
  beneficiaryId String      @db.Uuid

  created     DateTime @default(now())
  createdBy   User     @relation(fields: [createdById], references: [id])
  createdById String   @db.Uuid
}

model FollowupType {
  id              String  @id @db.Uuid
  name            String
  legallyRequired Boolean

  created     DateTime @default(now())
  createdBy   User?    @relation(fields: [createdById], references: [id])
  createdById String?  @db.Uuid

  followups    Followup[]
  helpRequests HelpRequest[]

  proposedFollowupTypes ProposedFollowupType[]

  ownedByStructure   Structure? @relation(fields: [ownedByStructureId], references: [id])
  ownedByStructureId String?    @db.Uuid

  @@unique([name, ownedByStructureId])
}

model ProposedFollowupType {
  structure   Structure @relation(fields: [structureId], references: [id])
  structureId String    @db.Uuid

  followupType   FollowupType @relation(fields: [followupTypeId], references: [id])
  followupTypeId String       @db.Uuid

  created DateTime @default(now())

  @@id([structureId, followupTypeId])
}

enum FollowupMedium {
  // Accueil physique sur rendez-vous
  PlannedInPerson
  // Accueil physique spontané
  UnplannedInPerson
  // Échange téléphonique
  PhoneCall
  // Rendez-vous à domicile
  BeneficiaryHouseAppointment
  // Rendez-vous extérieur
  ExternalAppointment
  // Courrier
  PostalMail
  // E-mail
  Email
  // Visioconférence
  Videoconference
  // Entretien avec un tiers
  ThirdParty
}

enum FollowupStatus {
  InProgress
  Done
}

model Followup {
  id String @id @db.Uuid

  structure   Structure @relation(fields: [structureId], references: [id])
  structureId String    @db.Uuid

  beneficiary   Beneficiary @relation(fields: [beneficiaryId], references: [id])
  beneficiaryId String      @db.Uuid

  createdById String? @db.Uuid
  createdBy   User?   @relation(name: "created_followups", fields: [createdById], references: [id])

  medium FollowupMedium
  date   DateTime       @db.Date

  type   FollowupType @relation(fields: [typeId], references: [id])
  typeId String       @db.Uuid

  synthesis String?

  status           FollowupStatus
  privateSynthesis String?

  helpRequested   Boolean?
  place           String?
  redirected      Boolean?
  structureName   String?
  dueDate         DateTime? @db.Date
  thirdPersonName String?

  created DateTime @default(now())
  updated DateTime @default(now())
}

enum HelpRequestStatus {
  // En attente de justificatifs
  WaitingForDocuments
  // En cours d'instruction
  WaitingForDecision
  // Accepté
  Accepted
  // Refusée
  Denied
}

enum PaymentMethod {
  // Virement
  WireTransfer
  // Carte bancaire
  CreditCard
  // Espèces
  Cash
  // Chèque
  Check
  // Bons alimentaire
  FoodStamps
}

enum HelpRequestReason {
  Energy
  Food
  Housing
}

model HelpRequest {
  id String @id @db.Uuid

  structure   Structure @relation(fields: [structureId], references: [id])
  structureId String    @db.Uuid

  beneficiary   Beneficiary @relation(fields: [beneficiaryId], references: [id])
  beneficiaryId String      @db.Uuid

  createdById String? @db.Uuid
  createdBy   User?   @relation(name: "created_help_requests", fields: [createdById], references: [id])

  openingDate DateTime @db.Date

  type   FollowupType @relation(fields: [typeId], references: [id])
  typeId String       @db.Uuid

  financialSupport  Boolean
  externalStructure Boolean
  status            HelpRequestStatus

  askedAmount Decimal?

  examinationDate DateTime? @db.Date
  decisionDate    DateTime? @db.Date

  allocatedAmount Decimal?

  paymentMethod      PaymentMethod?
  paymentDate        DateTime?      @db.Date
  handlingDate       DateTime?      @db.Date
  refusalReason      String?
  examiningStructure String?
  dispatchDate       DateTime?      @db.Date

  synthesis String?

  privateSynthesis String?

  dueDate DateTime? @db.Date

  fullFile Boolean?
  reason   HelpRequestReason?

  created DateTime @default(now())
  updated DateTime @default(now())
}

enum BeneficiaryStatus {
  // Actif
  Active
  // Inactif
  Inactive
  // Archivé
  Archived
  // Décédé
  Deceased
}

enum BeneficiaryTitle {
  // M.
  Mister
  // Mme.
  Miss
}

enum Gender {
  Male
  Female
  Other
}

enum BeneficiaryAccomodationMode {
  // Sans hébergement
  None
  // Propriétaire
  Owner
  // Locataire parc social
  SocialRenting
  // Locataire parc privé
  PrivateRenting
  // Logement de fortune
  Fortune
  // Hébergement de type CHRS, CHU, CPH, CADA...
  EmergencyHousing
  // Autre type de logement (hôtel...)
  Other
  // Hébergé chez un tiers
  ThirdPerson
  // Hébergé au domicile parental
  Parents
  // Logement insalubre
  Substandard
  // EHPAD, résidence sénior
  NursingHome
}

enum BeneficiaryFamilySituation {
  // Marié·e
  Married
  // Célibataire
  Single
  // Veuf·ve
  Widow
  // En concubinage
  Cohabitation
  // Pacsé
  CivilUnion
  // En couple avec enfant(s)
  CoupleWithChildren
  // Divorcé
  Divorced
  // Séparé
  Separated
  // Parent isolé avec enfant(s)
  SingleParentWithChildren
  // Autre
  Other
}

enum BeneficiaryMobility {
  //Permis B avec véhicule (voiture, moto, scooter)
  PermitWithVehicle
  //Permis B sans véhicule
  PermitWithoutVehicle
  //Code obtenu
  Code
  //Permis et/ou code en cours
  PermitPending
  //Autres permis (poids lourds, bus)
  OtherPermit
  //Dépendant des transports en commun
  PublicTransport
  //Vélo ou trottinette électrique
  BikeOrEquivalent
  //Permis non valide ou suspendu
  InvalidPermit
  //Véhicule sans permis
  VehicleWithoutPermit
  //Aucun moyen de transport à disposition
  Other
}

enum BeneficiaryGir {
  Level1
  Level2
  Level3
  Level4
  Level5
  Level6
}

enum BeneficiarySocioProfessionalCategory {
  Employed
  Retired
  JobSeeker
  Disability
  SickLeave
  Housewife
  NoActivity
  Other
}

enum IncomeSource {
  //RSA
  Rsa
  //Prime d'activité
  PrimeActivite
  //Prestations familiales
  PrestationsFamiliales
  //Indemnités Pôle Emploi
  IndemnitesPoleEmploi
  //Salaire
  Salaire
  //Retraite
  Retraite
  //ASPA
  Aspa
  //Pension d'invalidité
  PensionInvalidite
  //Indemnités journalières
  IndemnitesJournalieres
  //AAH
  Aah
  //APL
  Apl
  //Autre
  Autre
}

enum BeneficiaryProtectionMeasure {
  //Tutelle
  Tutelle
  //Curatelle simple
  CuratelleSimple
  //Curatelle renforcée
  CuratelleRenforcee
  //Sauvegarde de justice
  SauvegardeDeJustice
  //Habilitation du conjoint
  HabilitationDuConjoint
  //Habilitation familiale
  HabilitationFamiliale
  //Mesure d'accompagnement (Masp/Maj/MJAGBF)
  MesureAccompagnement
  //Mandat de protection future
  MandatDeProtectionFuture
}

enum BeneficiaryOrientationType {
  //Spontanée
  Spontanee
  //Orientation Élu
  Elu
  //Orientation Département
  Departement
  //Orientation Association
  Association
  //Signalement d'un tiers
  Tiers
  //Suivi cabinet
  SuiviCabinet
  //Autre
  Autre
}

model Beneficiary {
  id String @id @db.Uuid

  structure   Structure @relation(fields: [structureId], references: [id])
  structureId String    @db.Uuid

  createdById String? @db.Uuid
  createdBy   User?   @relation(name: "created_beneficiaries", fields: [createdById], references: [id])
  referents   User[]  @relation(name: "beneficiary_referents")

  aidantConnectAuthorized Boolean @default(false)

  // General information
  fileNumber                        String                       @unique
  status                            BeneficiaryStatus
  title                             BeneficiaryTitle?
  usualName                         String?
  birthName                         String?
  firstName                         String?
  birthDate                         DateTime?                    @db.Date
  birthPlace                        String?
  deathDate                         DateTime?                    @db.Date
  gender                            Gender?
  nationality                       String?
  accomodationMode                  BeneficiaryAccomodationMode?
  accomodationName                  String?
  accomodationAdditionalInformation String?
  street                            String?
  streetNumber                      String?
  addressComplement                 String?
  zipcode                           String?
  city                              String?
  noPhone                           Boolean?
  phone1                            String?
  phone2                            String?
  email                             String?
  familySituation                   BeneficiaryFamilySituation?
  caregiver                         Boolean?
  minorChildren                     Int?
  majorChildren                     Int?
  mobility                          BeneficiaryMobility?
  administration                    String?
  minister                          String?

  relatives BeneficiaryRelative[]

  // Health
  gir                         BeneficiaryGir?
  doctor                      String?
  healthAdditionalInformation String?
  socialSecurityNumber        String?
  insurance                   String?

  // Occupation
  socioProfessionalCategory     BeneficiarySocioProfessionalCategory?
  occupation                    String?
  employer                      String?
  employerSiret                 String?
  mainIncomeSource              IncomeSource[]
  mainIncomeAmount              Decimal?
  partnerMainIncomeSource       IncomeSource[]
  partnerMainIncomeAmount       Decimal?
  majorChildrenMainIncomeSource IncomeSource[]
  majorChildrenMainIncomeAmount Decimal?
  unemploymentNumber            String?
  pensionStructure              String?
  cafNumber                     String?
  bank                          String?
  funeralContract               String?

  // External Structures
  protectionMeasure    BeneficiaryProtectionMeasure?
  representative       String?
  prescribingStructure String?
  orientationType      BeneficiaryOrientationType?
  orientationStructure String?
  serviceProviders     String?
  involvedPartners     String?

  additionalInformation String?

  documents    Document[]
  followups    Followup[]
  helpRequests HelpRequest[]

  created            DateTime      @default(now())
  updated            DateTime      @default(now())
  targetForMutations MutationLog[]
}

enum RelativeRelationship {
  //Conjoint
  Conjoint
  //Enfant mineur
  EnfantMineur
  //Enfant majeur
  EnfantMajeur
  //Parent
  Parent
  //Grand-parent
  Grandparent
  //Voisin
  Neighbour
  //Fratrie
  Fratrie
  //Tiers
  Tiers
  //Autre membre de la famille
  AutreMemberDeLaFamille
}

model BeneficiaryRelative {
  id           String                @id @db.Uuid
  lastName     String?
  firstName    String?
  relationship RelativeRelationship?

  city  String?
  email String?
  phone String?

  hosted    Boolean?
  caregiver Boolean?

  beneficiary   Beneficiary @relation(fields: [beneficiaryId], references: [id])
  beneficiaryId String      @db.Uuid

  additionalInformation String?

  created DateTime @default(now())
  updated DateTime @default(now())
}

model VerificationToken {
  token      String   @id
  identifier String // Email or other user identifier
  expires    DateTime

  @@unique([identifier, token])
}

enum MutationSource {
  User
  Admin
  System
}

model MutationLog {
  id     String         @id @db.Uuid
  date   DateTime
  source MutationSource

  // User that did the mutation
  by   User?   @relation(name: "mutation_by", fields: [byId], references: [id])
  byId String? @db.Uuid

  // Name of the mutation or feature
  name String

  // If the mutation impacts a user
  targetUser   User?   @relation(name: "mutation_target", fields: [targetUserId], references: [id])
  targetUserId String? @db.Uuid

  // If the mutation impacts an aggregate owned by a structure (applies to beneficiaries, ...)
  targetStructure   Structure? @relation(fields: [targetStructureId], references: [id])
  targetStructureId String?    @db.Uuid

  // If the mutation impacts an aggregate owned by a beneficiary (applies to followups, documents...)
  targetBeneficiary   Beneficiary? @relation(fields: [targetBeneficiaryId], references: [id])
  targetBeneficiaryId String?      @db.Uuid

  // Id of the object target of the mutation, if applicable (can be a document id or followup id...)
  targetId String?

  // Data diff intent of the mutation
  data Json
}
